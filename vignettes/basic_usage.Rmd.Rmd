---
title: "phyloseqExtra basic usage"
author: "Chenghao Zhu"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{phyloseqExtra basic usage}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE, warning = FALSE, error = FALSE,
  fig.height = 4, fig.width = 6, fig.align = "center"
)
```

# phyloseqExtra

Microbiome data generated by high through-put sequecing methods come with the phylogenic taxonomy informtation which is a hierachical. Researches often need to group OTUs/features base on their phylogenic information on different levels in order to find any potential point of interests. The phyloseqExtra is a R package allows user to look at the phylogenic sequencing data in different phylogenic levels. As it iss named the core component of this package was built based on the [phyloseq](http://bioconductor.org/packages/release/bioc/html/phyloseq.html) package. This tutorial shows a basic workflow of using this package to analyze microbiome data.

## Install

This package can be installed from github.

```{r install, eval = FALSE}
devtools::install_github("zhuchcn/phyloseqExtra")
```

## Create a SummarizedPhyloseq object

The workflow starts with the OTU/feature clustered OTU/feature table with taxonomy table to each OTU/feature. To generate the OTU/feature table, please refer to the [QIIME2](https://docs.qiime2.org/) or the [dada2](https://benjjneb.github.io/dada2/tutorial.html) tutorial. You need the three tables below in order to start.

* OTU/feature table
* Taxonomy table
* Sample meta-data table

The 3 tables are first imported into a phyloseq object, followed by summarizing into a SummarizedPhyloseq object. The SummarizedPhyloseq is a S4 class inherits from the phyloseq-class from the phyloseq package, that contains 7 additional slots from species to kingdom to store the summarized abundance table.

```{r SummarizedPhyloseq}
library(phyloseq); library(phyloseqExtra)
data(fatigue)
fatigue = fix_duplicate_tax(fatigue)
spy = summarizeFromPhyloseq(fatigue)
spy
```

## Statistic analysis on all phylogenic levles

Researches often want to do hypothesis testing between different study group, population, or any other sample variable. We provide a encapsulated function to do statistic analysis on count data using the DESeq2 package, or relative abundant data using limma package, and then store the statistic results in a SummarizedPhyloStats object. These functions require the DESeq2 or limma packages pre-installed in your enviroment. These two packages can be installed from the bioconductor.

* DESeq2

```{r SummarizedPhyloStats-deseq2}
design = model.matrix(data = as(sample_data(fatigue), "data.frame"),
                      ~Subject + 1)
spys_de = spy_to_deseq2(spy, design, resultsName = "SubjectPatient")
spys_de
```

* limma

```{r SummarizedPhyloStats-limma}
spy_prop = summarizeFromPhyloseq(transform_sample_counts(fatigue, function(x) x/sum(x)))
spys_lm = spy_to_limma(spy_prop, design, p.value = 2, coef = 2)
spys_lm
```

## Stacked Barplot

The plot_bar() function can be used to quickly generate barplots. The function takes 5 arguments, a SummarizedPhyloseq object, a character variable *level* to specify the phylogenic level, a character variable *by* from the sample meta-data column names, a logical variable *show.legend*, and a logical variable *plotly*. The output is a ggplot object so you can add any ggplot function on it.

```{r barplot-1}
plot_bar(spy_prop)
```

The default value for level is *Phylum*. If the *by* argument is not specified, the sample id will be used and each sample will be an individual bar.

The *by* variable can take up to 3 elements.

```{r barplot-2}
plot_bar(spy_prop, level = "Phylum", by = c("Subject", "Sex"))
```

```{r barplot-3}
plot_bar(spy_prop, level = "Genus", by = c("Subject", "Sex", "age_range"), show.legend = F, plotly = T )
```

## Boxplot function

The boxplot function takes more arguments. Please refer to the help document for the usage of each arguments. 

* Basic usage:

```{r boxplot-1}
plot_box(spy_prop, level = "Genus", taxon = "g__Ruminococcus", by = "Subject")
```

* the *jitter* argument will move the points around so they are less overlapping.

```{r boxplot-2}
plot_box(spy_prop, level = "Genus", taxon = "g__Ruminococcus", by = c("Subject","Sex"), jitter = 0.15)
```

* The points can be removed

```{r boxplot-3}
plot_box(spy_prop, level = "Genus", taxon = "g__Ruminococcus", by = c("Subject", "Sex"), show.points = FALSE)
```

* A pre-defined style *academic* can be called to generate a clean style for journal articles.

```{r boxplot}
plot_box(spy_prop, level = "Genus", taxon = "g__Ruminococcus", by = c("Subject","Sex"), jitter = 0.15, box.size = 1, whisker.size = 1, point.alpha = 0.75, point.color = "steelblue", style = "academic")
```

The plot_box function also can draw lines by specifying the *line* argument. This is particually usful for repearted measures.

## Cladogram with microbiomeViz

Cladogram is a very useful visualization method for microbiome data with different phylogenic levels. Most current popular cladogram visualization tools are not able to use flexible statistic methods fo annotation. Here we provide a solution combining with the [microbiomeViz](https://github.com/lch14forever/microbiomeViz) package. Below is an example using the DESeq2 result to annotate the cladogram

```{r cladogram,fig.width=10.5, fig.height = 7}
library(ggplot2);library(microbiomeViz)
tr = parsePhyloseq(fatigue, node.size.scale = 1.25)
p = tree.backbone(tr, size=1)
anno.data = create_annodata(spys_de, coef = "padj", cutoff = 0.05)
p = clade.anno(p, anno.data)
p
```

The cladogram is a ggplot object, so it can take the theme function from ggplot for further formating.

```{r cladogram-formated, fig.width=10.5, fig.height = 7}
p + geom_point(
    data=data.frame(x=1:2,  y=1:2, color=c("Control","Patient")),
    aes(x=x, y=y, color=color), size=0, stroke=0) +
    guides(
        color = guide_legend(
            override.aes = list(size=3, color= rev(c("#00468BFF", "#ED0000FF")))
        )) +
    theme(
    legend.text = element_text(size = 11),
    plot.margin = margin(l=0, r=160, t=0, b=0)
)
```

